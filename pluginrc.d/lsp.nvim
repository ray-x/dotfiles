if &diff
  finish
endif

nnoremap <buffer> <silent> <C-LeftMouse> <LeftMouse> <cmd>lua vim.lsp.buf.definition()<CR>
nnoremap <buffer> <silent> g<LeftMouse> <LeftMouse> <cmd>lua vim.lsp.buf.implementation()<CR>

imap <c-j> <cmd>lua require'completion.source'.prevCompletion()<CR>
imap <c-k> <cmd>lua require'completion.source'.nextCompletion()<CR>

autocmd Filetype go,lua,c,cpp,javascript,typescript setlocal omnifunc=v:lua.vim.lsp.omnifunc


" Configure the completion chains

" let g:completion_chain_complete_list = [
"         \  {'complete_items': ['lsp']},
"         \  {'complete_items': ['snippet']},
"         \  {'complete_items': ['ts', 'tablenine']},
"         \  {'complete_items': ['path']},
"         \  {'mode': '<c-p>'},
"         \  {'mode': '<c-n>'}]

" let g:completion_chain_complete_list = {
"       \'default' : {
"       \ 'default' : [
"       \   {'complete_items' : ['lsp', 'snippet']},
"       \   {'mode' : 'file'}
"       \ ],
"       \ 'comment' : [],
"       \ 'string' : []
"       \ },
"       \'vim' : [
"       \ {'complete_items': ['snippet']},
"       \ {'mode' : 'cmd'}
"       \ ],
"       \'c' : [
"       \ {'complete_items': ['ts']}
"       \ ],
"       \'python' : [
"       \ {'complete_items': ['ts']}
"       \ ],
"       \'lua' : [
"       \ {'complete_items': ['ts']}
"       \ ],
"       \}
" let g:completion_chain_complete_list = {
"     \ 'default' : {
"     \   'default': [
"     \       {'complete_items': ['lsp', 'snippet']},
"     \       {'mode': '<c-p>'},
"     \       {'mode': '<c-n>'}],
"     \   'comment': [],
"     \   'string': []
"     \   }
"     \}

" let g:completion_chain_complete_list = {
"     \ 'default' : {
"     \   'default': [
"     \       {'complete_items': ['lsp']},
"     \       {'complete_items': ['snippet', 'tabnine', 'ts']},
"     \       {'complete_items': ['path'], 'triggered_only': ['/']},
"     \       {'mode': '<c-p>'},
"     \       {'mode': '<c-n>'}],
"     \   'func' : [{'complete_items': ['lsp']}, {'complete_items': ['snippet','ts','tabnine']}],
"     \   'comment': [{'complete_items': ['buffer', 'tabnine']}],
"     \   'string':  [{'complete_items': ['buffer', 'tabnine']}]
"     \   }
"     \}

let g:completion_chain_complete_list = {
    \ 'default' : {
    \   'default': [
    \       {'complete_items': ['lsp','tabnine','snippet']},
    \       {'complete_items': ['ts','buffer']},
    \       {'complete_items': ['path'], 'triggered_only': ['/']},
    \       {'mode': '<c-p>'},
    \       {'mode': '<c-n>'}],
    \   'func' : [{'complete_items': ['lsp']}, {'complete_items': ['snippet','ts','tabnine']}],
    \   'comment': [{'complete_items': ['buffer', 'tabnine']}],
    \   'string':  [{'complete_items': ['buffer', 'tabnine']}]
    \   }
    \}


" inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
" inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
" let g:completion_confirm_key = "\<C-y>"

let g:completion_confirm_key = ""

imap <expr> <cr>  pumvisible() ? complete_info()["selected"] != "-1" ?
                \ "\<Plug>(completion_confirm_completion)"  : "\<c-e>\<CR>" :  "\<CR>"

" inoremap <expr> <cr>  pumvisible() ? complete_info()["selected"] != "-1" ?  "\<C-n>\<CR>"  : "\<c-e>\<CR>" :  "\<CR>"
" imap <expr> <cr>  pumvisible() ? complete_info()["selected"] != "-1" ? "\<Plug>(completion_confirm_completion)"  : "\<c-e>\<CR>" :  "\<CR>" 
" imap <expr> <CR> pumvisible() ? (complete_info().selected == -1 ? '\<C-n><Plug>(completion_confirm_completion)' : '\<Plug>(completion_confirm_completion)') : '\<CR>'

let g:completion_enable_auto_signature = 1

set shortmess+=c

function! s:check_back_space() abort
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~ '\s'
endfunction

inoremap <silent><expr> <TAB>
  \ pumvisible() ? "\<C-n>" :
  \ <SID>check_back_space() ? "\<TAB>" :
  \ completion#trigger_completion()

let g:completion_enable_snippet = 'vim-vsnip'  " 'UltiSnips' 'vim-vsnip'

let g:completion_matching_strategy_list = ['exact', 'all', 'substring', 'fuzzy']   "'fuzzy','all'" , 'substring' 'exact'
let g:completion_trigger_character = ['.']

augroup CompletionTriggerCharacter
    autocmd!
    autocmd BufEnter *.c,*.cpp let g:completion_trigger_character = ['.', '::', '->']
augroup end

" let g:completion_trigger_keyword_length = 1

""""tab9
" max tabnine completion options(default 7)
let g:completion_tabnine_max_num_results=12

let g:completion_tabnine_priority = 2

" sort by tabnine score (default 0)
let g:completion_tabnine_sort_by_details=1

" max line for tabnine input(default 1000)
" from current line -1000 ~ +1000 lines is passed as input
" to check if the value override
let g:completion_tabnine_max_lines=999

imap <c-j> <Plug>(completion_next_source)
"use <c-j> to switch to previous completion
imap <c-k> <Plug>(completion_prev_source)
"use <c-k> to switch to next completion

" completion
let g:completion_auto_change_source = 1
"  sorting via length descending
" possible value: "length", "alphabet", "none"
let g:completion_sorting = "length"
let g:completion_matching_ignore_case = 1


let g:completion_customize_lsp_label = {
      \ 'Function': "\uf794",
      \ 'Method': "\uf6a6",
      \ 'Variable': "\uf71b",
      \ 'Constant': "\uf8ff",
      \ 'Struct': "\ufb44",
      \ 'Class': "\uf0e8",
      \ 'Interface': "\ufa52",
      \ 'Text': "\ue612",
      \ 'Enum': "\uf435",
      \ 'EnumMember': "\uf02b",
      \ 'Module': "\uf668",
      \ 'Color': "\ue22b",
      \ 'Property': "\ufab6",
      \ 'Field': "\uf93d",
      \ 'Unit': "\uf475",
      \ 'File': "\uf471",
      \ 'Value': "\uf8a3",
      \ 'Event': "\ufacd",
      \ 'Folder': "\uf115",
      \ 'Keyword': "\uf893",
      \ 'Snippet': "\uf64d",
      \ 'Operator': "\uf915",
      \ 'Reference': "\uf87a",
      \ 'TypeParameter': "\uf278",
      \ 'Default': "\uf29c"
      \}
" https://github.com/vn-ki/coc-clap/blob/master/autoload/clap/provider/coc_symbols.vim"
" all lsp types"
let g:completion_items_priority = {
        \ 'Field': 8,
        \ 'Function': 8,
        \ 'Variable': 8,
        \ 'Variables': 7,
        \ 'Method': 10,
        \ 'Interfaces': 6,
        \ 'Constant': 6,
        \ 'Interface': 8,
        \ 'Text': 4,
        \ 'Enum': 5,
        \ 'EnumMember': 5,
        \ 'Module': 4,
        \ 'Property': 6,
        \ 'Unit': 7,
        \ 'Value': 3,
        \ 'Reference': 4,
        \ 'TypeParameter': 5,
        \ 'Default': 2,
        \ 'Class': 6,
        \ 'Struct': 6,
        \ 'Keyword': 5,
        \ 'Treesitter': 4,
        \ 'vim-vsnip' : 1,
        \ 'Snippet' :1,
        \ 'Buffers' : 1,
        \ 'TabNine' : 2,
        \ 'File' : 2,
        \}
"         \ 'UltiSnips' : 0,          \ 'Neosnippet' : 0,
" let g:diagnostic_insert_delay = 1


augroup CompletionMD
    autocmd!
    autocmd BufEnter *.md let g:completion_matching_strategy_list = ['substring'] | let g:completion_items_priority = { 'Buffers' : 3, 'TabNine' : 6, 'File' : 5, 'vim-vsnip' : 8 } |let g:completion_chain_complete_list = [ {'ins_complete': v:false, 'complete_items': ['snippet', 'tabnine', 'buffer']},{'mode': '<c-p>'},{'mode': '<c-n>'}]
augroup end



let g:lsp_log_verbose = 1
let g:lsp_log_file = expand('/tmp/lsp.log')
let g:float_preview#docked = 1




let g:diagnostic_enable_virtual_text = 1
let g:diagnostic_enable_underline = 1
let g:diagnostic_auto_popup_while_jump = 1
let g:diagnostic_insert_delay = 1
" let g:nvim_lsp = 1 "this disable lsp_config


sign define LspDiagnosticsSignError text=  linehl= texthl=LspDiagnosticsSignError numhl=                        
sign define LspDiagnosticsSignWarning text=  linehl= texthl=LspDiagnosticsSignWarning numhl=                    
sign define LspDiagnosticsSignInformation text=כֿ  linehl= texthl=LspDiagnosticsSignInformation numhl=            
sign define LspDiagnosticsSignHint text=λ  linehl= texthl=LspDiagnosticsSignHint numhl= 

function! LspStatus() abort
    let sl = ''
    if luaeval('not vim.tbl_isempty(vim.lsp.buf_get_clients(0))')
        let sl.='%#MyStatuslineLSP#E:'
        let sl.='%#MyStatuslineLSPErrors#%{luaeval("vim.lsp.util.buf_diagnostics_count([[Error]])")}'
        let sl.='%#MyStatuslineLSP# W:'
        let sl.='%#MyStatuslineLSPWarnings#%{luaeval("vim.lsp.util.buf_diagnostics_count([[Warning]])")}'
    else
        let sl.='%#MyStatuslineLSPErrors#off'
    endif
    return sl
endfunction
" start the lsp for specific file type
" lua require('lsp_config')


if executable('sqls')
    augroup LspSqls
        autocmd!
        autocmd User lsp_setup call lsp#register_server({
        \   'name': 'sqls',
        \   'cmd': {server_info->['sqls']},
        \   'whitelist': ['sql'],
        \   'workspace_config': {
        \     'sqls': {
        \       'connections': [
        \         {
        \           'driver': 'postgresql',
        \           'dataSourceName': 'host=127.0.0.1 port=15432 user=user_db password=svcpass dbname=tag sslmode=disable',
        \         },
        \         {
        \           'driver': 'postgresql',
        \           'dataSourceName': 'host=127.0.0.1 port=15432 user=user_db password=svcpass dbname=user sslmode=disable',
        \         },
        \       ],
        \     },
        \   },
        \ })
    augroup END
endif
