if &diff
  finish
endif

nnoremap <buffer> <silent> <C-LeftMouse> <LeftMouse> <cmd>lua vim.lsp.buf.definition()<CR>
nnoremap <buffer> <silent> g<LeftMouse> <LeftMouse> <cmd>lua vim.lsp.buf.implementation()<CR>

inoremap <silent><expr> <C-Space> compe#complete()
inoremap <silent><expr> <CR>      compe#confirm({ 'keys': "\<Plug>delimitMateCR", 'mode': '' })
inoremap <silent><expr> <C-e>     compe#close('<C-e>')
inoremap <silent><expr> <C-f>     compe#scroll({ 'delta': +4 })
inoremap <silent><expr> <C-d>     compe#scroll({ 'delta': -4 })

autocmd Filetype go,lua,c,cpp,javascript,typescript setlocal omnifunc=v:lua.vim.lsp.omnifunc

" inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
" inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

let g:completion_enable_auto_signature = 1

function! s:check_back_space() abort
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~ '\s'
endfunction

inoremap <silent><expr> <TAB>
  \ pumvisible() ? "\<C-n>" :
  \ <SID>check_back_space() ? "\<TAB>" :
  \ completion#trigger_completion()



imap <c-j> <Plug>(completion_next_source)
"use <c-j> to switch to previous completion
imap <c-k> <Plug>(completion_prev_source)
"use <c-k> to switch to next completion



" let g:diagnostic_insert_delay = 1


augroup CompletionMD
    autocmd!
    autocmd BufEnter *.md let g:completion_matching_strategy_list = ['substring'] | let g:completion_items_priority = { 'Buffers' : 3, 'TabNine' : 6, 'File' : 5, 'vim-vsnip' : 8 } |let g:completion_chain_complete_list = [ {'ins_complete': v:false, 'complete_items': ['snippet', 'tabnine', 'buffer']},{'mode': '<c-p>'},{'mode': '<c-n>'}]
augroup end



let g:lsp_log_verbose = 1
let g:lsp_log_file = expand('/tmp/lsp.log')
let g:float_preview#docked = 1


let g:diagnostic_enable_virtual_text = 1
let g:diagnostic_enable_underline = 1
let g:diagnostic_auto_popup_while_jump = 1
let g:diagnostic_insert_delay = 1
" let g:nvim_lsp = 1 "this disable lsp_config

function! LspStatus() abort
    let sl = ''
    if luaeval('not vim.tbl_isempty(vim.lsp.buf_get_clients(0))')
        let sl.='%#MyStatuslineLSP#E:'
        let sl.='%#MyStatuslineLSPErrors#%{luaeval("vim.lsp.util.buf_diagnostics_count([[Error]])")}'
        let sl.='%#MyStatuslineLSP# W:'
        let sl.='%#MyStatuslineLSPWarnings#%{luaeval("vim.lsp.util.buf_diagnostics_count([[Warning]])")}'
    else
        let sl.='%#MyStatuslineLSPErrors#off'
    endif
    return sl
endfunction
" start the lsp for specific file type
" lua require('lsp_config')


if executable('sqls')
    augroup LspSqls
        autocmd!
        autocmd User lsp_setup call lsp#register_server({
        \   'name': 'sqls',
        \   'cmd': {server_info->['sqls']},
        \   'whitelist': ['sql'],
        \   'workspace_config': {
        \     'sqls': {
        \       'connections': [
        \         {
        \           'driver': 'postgresql',
        \           'dataSourceName': 'host=127.0.0.1 port=15432 user=user_db password=svcpass dbname=tag sslmode=disable',
        \         },
        \         {
        \           'driver': 'postgresql',
        \           'dataSourceName': 'host=127.0.0.1 port=15432 user=user_db password=svcpass dbname=user sslmode=disable',
        \         },
        \       ],
        \     },
        \   },
        \ })
    augroup END
endif

