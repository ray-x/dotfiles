" finish
" if &diff
"   finish
" endif




nnoremap <buffer> <silent> <C-LeftMouse> <LeftMouse> <cmd>lua vim.lsp.buf.definition()<CR>
nnoremap <buffer> <silent> g<LeftMouse> <LeftMouse> <cmd>lua vim.lsp.buf.implementation()<CR>

imap <c-j> <cmd>lua require'completion.source'.prevCompletion()<CR>
imap <c-k> <cmd>lua require'completion.source'.nextCompletion()<CR>

autocmd Filetype go,lua,c,cpp,javascript,typescript setlocal omnifunc=v:lua.vim.lsp.omnifunc


" Configure the completion chains

" let g:completion_chain_complete_list = {
"       \'default' : {
"       \ 'default' : [
"       \   {'complete_items' : ['lsp', 'snippet']},
"       \   {'mode' : 'file'}
"       \ ],
"       \ 'comment' : [],
"       \ 'string' : []
"       \ },
"       \'vim' : [
"       \ {'complete_items': ['snippet']},
"       \ {'mode' : 'cmd'}
"       \ ],
"       \'c' : [
"       \ {'complete_items': ['ts']}
"       \ ],
"       \'python' : [
"       \ {'complete_items': ['ts']}
"       \ ],
"       \'lua' : [
"       \ {'complete_items': ['ts']}
"       \ ],
"       \}
" let g:completion_chain_complete_list = {
"     \ 'default' : {
"     \   'default': [
"     \       {'complete_items': ['lsp', 'snippet']},
"     \       {'mode': '<c-p>'},
"     \       {'mode': '<c-n>'}],
"     \   'comment': [],
"     \   'string': []
"     \   }
"     \}

let g:completion_chain_complete_list = {
    \ 'default' : {
    \   'default': [
    \       {'complete_items': ['lsp','snippet']},
    \       {'complete_items': ['tablenine', 'ts']},
    \       {'complete_items': ['path'], 'triggered_only': ['/']},
    \       {'mode': '<c-p>'},
    \       {'mode': '<c-n>'}],
    \   'func' : [{'complete_items': ['lsp']}, {'complete_items': ['snippet','ts','tablenine']}],
    \   'comment': [{'complete_items': ['buffer', 'tablenine']}],
    \   'string':  [{'complete_items': ['buffer', 'tablenine']}]
    \   }
    \}


" inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
" inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
" let g:completion_confirm_key = "\<C-y>"
" let g:completion_confirm_key = ""
imap <expr> <cr>  pumvisible() ? complete_info()["selected"] != "-1" ?
                 \ "\<Plug>(completion_confirm_completion)"  : "\<c-e>\<CR>" :  "\<CR>"
set shortmess+=c


function! s:check_back_space() abort
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~ '\s'
endfunction

inoremap <silent><expr> <TAB>
  \ pumvisible() ? "\<C-n>" :
  \ <SID>check_back_space() ? "\<TAB>" :
  \ completion#trigger_completion()

let g:completion_enable_snippet = 'vim-vsnip'  " 'UltiSnips' 'vim-vsnip'

let g:completion_matching_strategy_list = [ 'exact', 'all', 'substring', 'fuzzy']   "'fuzzy','all'" , 'substring' 'exact'
let g:completion_trigger_character = ['.']

augroup CompletionTriggerCharacter
    autocmd!
    autocmd BufEnter *.c,*.cpp let g:completion_trigger_character = ['.', '::', '->']
augroup end

" let g:completion_trigger_keyword_length = 1

""""tab9
" max tabnine completion options(default 7)
let g:completion_tabnine_max_num_results=12

" sort by tabnine score (default 0)
let g:completion_tabnine_sort_by_details=0

" max line for tabnine input(default 1000)
" from current line -1000 ~ +1000 lines is passed as input
" to check if the value override
let g:completion_tabnine_max_lines=499

" completion
let g:completion_auto_change_source = 1
"  sorting via length descending
" possible value: "length", "alphabet", "none"
let g:completion_sorting = "length"
let g:completion_matching_ignore_case = 1


let g:completion_customize_lsp_label = {
      \ 'Function': "\uf794",
      \ 'Method': "\uf6a6",
      \ 'Variable': "\uf71b",
      \ 'Constant': "\uf8ff",
      \ 'Struct': "\ufb44",
      \ 'Class': "\uf0e8",
      \ 'Interface': "\ufa52",
      \ 'Text': "\ue612",
      \ 'Enum': "\uf435",
      \ 'EnumMember': "\uf02b",
      \ 'Module': "\uf668",
      \ 'Color': "\ue22b",
      \ 'Property': "\ufab6",
      \ 'Field': "\uf93d",
      \ 'Unit': "\uf475",
      \ 'File': "\uf471",
      \ 'Value': "\uf8a3",
      \ 'Event': "\ufacd",
      \ 'Folder': "\uf115",
      \ 'Keyword': "\uf893",
      \ 'Snippet': "\uf64d",
      \ 'Operator': "\uf915",
      \ 'Reference': "\uf87a",
      \ 'TypeParameter': "\uf278",
      \ 'Default': "\uf29c"
      \}

let g:completion_items_priority = {
        \ 'Field': 8,
        \ 'Function': 8,
        \ 'Variable': 8,
        \ 'Variables': 7,
        \ 'Method': 10,
        \ 'Interfaces': 6,
        \ 'Constant': 6,
        \ 'Interface': 8,
        \ 'Text': 4,
        \ 'Enum': 5,
        \ 'EnumMember': 5,
        \ 'Module': 4,
        \ 'Property': 6,
        \ 'Unit': 7,
        \ 'Value': 3,
        \ 'Reference': 4,
        \ 'TypeParameter': 5,
        \ 'Default': 2,
        \ 'Class': 6,
        \ 'Struct': 6,
        \ 'Keyword': 5,
        \ 'Treesitter': 4,
        \ 'vim-vsnip' : 1,
        \ 'Snippet' :1,
        \ 'Buffers' : 1,
        \ 'TabNine' : 1,
        \ 'File' : 2,
        \}
"         \ 'UltiSnips' : 0,          \ 'Neosnippet' : 0,
" let g:diagnostic_insert_delay = 1


augroup CompletionMD
    autocmd!
    autocmd BufEnter *.md let g:completion_matching_strategy_list = ['substring'] | let g:completion_items_priority = { 'Buffers' : 3, 'TabNine' : 6, 'File' : 5, 'vim-vsnip' : 8 } |let g:completion_chain_complete_list = [ {'ins_complete': v:false, 'complete_items': ['snippet', 'tabnine', 'buffer']},{'mode': '<c-p>'},{'mode': '<c-n>'}]
augroup end



let g:lsp_log_verbose = 1
let g:lsp_log_file = expand('/tmp/lsp.log')
let g:float_preview#docked = 1




let g:diagnostic_enable_virtual_text = 1
let g:diagnostic_enable_underline = 1
let g:diagnostic_auto_popup_while_jump = 1
let g:diagnostic_insert_delay = 1
" let g:nvim_lsp = 1 "this disable lsp_config



sign define LspDiagnosticsErrorSign text=  linehl= texthl=LspDiagnosticsErrorSign numhl=                        
sign define LspDiagnosticsWarningSign text=  linehl= texthl=LspDiagnosticsWarningSign numhl=                    
sign define LspDiagnosticsInformationSign text=כֿ  linehl= texthl=LspDiagnosticsInformationSign numhl=            
sign define LspDiagnosticsHintSign text=λ  linehl= texthl=LspDiagnosticsHintSign numhl= 

function! LspStatus() abort
    let sl = ''
    if luaeval('not vim.tbl_isempty(vim.lsp.buf_get_clients(0))')
        let sl.='%#MyStatuslineLSP#E:'
        let sl.='%#MyStatuslineLSPErrors#%{luaeval("vim.lsp.util.buf_diagnostics_count([[Error]])")}'
        let sl.='%#MyStatuslineLSP# W:'
        let sl.='%#MyStatuslineLSPWarnings#%{luaeval("vim.lsp.util.buf_diagnostics_count([[Warning]])")}'
    else
        let sl.='%#MyStatuslineLSPErrors#off'
    endif
    return sl
endfunction


" start the lsp"
lua require('lsp_config')
